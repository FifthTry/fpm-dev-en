-- ft.page: How sync & CR works


-- ft.h1: State

State is represented by what is with the server and what is with the client.

-- ft.h2: Server State

Server state is composed of history of all files, and the tracking information
about all files.

-- ft.code:
lang: ftd

\-- record server-state:
file-history list history:
file-tracking list tracks:

-- ft.markdown:

File history captures every modification to a file. It also included information
about changes that happened due to merges, if an action happened to "main
branch" via merge from a CR, we store the CR where the change came from in the
`src-cr` field.

-- ft.code:
lang: ftd

\-- record file-history:
caption filename:
file-edit list history:

\-- or-type file-edit:
\--- added:
caption or body message:
integer timestamp:
integer version:
string author:
option integer src-cr:

\--- updated:
caption or body message:
integer timestamp:
integer version:
string author:
option integer src-cr:

\--- deleted:
caption or body message:
integer timestamp:
integer version:
string author:
option integer src-cr:

-- ft.markdown:

Actual content is stored in the file system based on
`<file-name-without-last-extension>.<version>.<extension>`.

Also `version` starts with 1 for every file, and is incremented by one for every
change in that file. Delete also increments the version number.

A file can track one or more files. Any file that is tracking another file has
an entry in `server-state.track`, represented by `file-tracking`.

-- ft.code:
lang: ftd

\-- record file-tracking:
caption filename:
tracking-info list tracks:

-- ft.markdown:

Every file that is being tracked is recorded using `tracking-info`.

-- ft.code:
lang: ftd

\-- record tracking-info:
caption filename:
integer version:
option integer self-version:

-- ft.markdown:

Say `a.ftd` is tracking `b.ftd`. We have some operation that mark `a.ftd` up to
date with `b.ftd`. This can happen when a we sync with remote, say if a was
local and b was remote version of same file. This can happen when the author
performs `fpm mark-up-to-date` action if a is tracking b in an ad-hoc fashion,
or if a is a translation of b. This can also happen when a merge happens from
CR, if a was CR version of b, and was being merged into b.

`version` represents the version of `b.ftd` , and `self-version`
represents the version of `a.ftd`.

-- ft.h1: Client State

On the client the state is largely two: workspace content and the unsynced
tracking information.

-- ft.code:
lang: ftd

\-- record client-state:
workspace-entry list workspace:
file-tracking list unsynced-tracks:

\-- record workspace-entry:
caption filename:
optional boolean deleted:
integer version:


-- ft.markdown:

Client state is stored in `.client-state` folder. Workspace information is
stored in `.client-state/workspace.ftd` and unsynced changes are stored in
`.client-state/unsynced.tracks.ftd`.

-- ft.h1: Operations

Given current server and client state, a bunch of operations are there, which
either print some output, or update either the client or server state.

-- ft.h2: `fpm clone`

This command starts with remote state and no client state, and fetches client
state and lays things out.

It also stores the server state in `.server-state` folder. This folder contains
`history.ftd`, `tracks.ftd` and `index.1.ftd` etc.

-- ft.h2: `fpm start-tracking a.ftd b.ftd`



-- ft.h2: `fpm status`

This shows the changes on local.

-- ft.h2: `fpm sync`

On client, some files are updated, if there is a mergable change on server,
along with their entries in workspace file.

On every sync we also copy and update the `server-state` to `.server-state`
folder.


-- ft.h1: `.fpm/workspace.ftd`

After fpm clone, the .fpm/workspace.ftd created. This contains entry for all the
files in the file system. It is hashmap of filename to version.

The only time the workspace is updated is when we do a sync or resolve a conflict.


-- ft.code:
lang: ftd

\-- fpm.workspace-file: <filename>
timestamp: <timestamp>



-- ft.h1: `.history/history.ftd`

This contains the history related information for the files


-- ft.code:
lang: ftd


\-- fpm.history-file: <filename>

\--- action.add:
timestamp: <timestamp>







-- ft.h1: `new-file-added`

Before sync:

Create file in file system

After sync:
- .history/index.v1.ftd
- Create entry in .latest.ftd
- Create entry .history/history.ftd

-- ft.code:
lang: ftd

\-- fpm.history: index.ftd

\--- fpm.status: Added
timestamp: v1

-- ft.markdown:

- Create entry in `.fpm/workspace.ftd`


-- ft.h1: `new-file-added-after-already-added`

Before sync:

Create file in file system

After sync:
- Return conflict (index.v1.ftd: content and version)
- Create entry in .fpm/workspace.ftd

-- ft.code:
lang: ftd

\-- fpm.workspace: index.ftd
status: conflicted
version: v1

-- ft.markdown:

- Don't modify index.ftd in fs



-- ft.h1: `file-deleted`

Before sync:

Delete file in file system

After sync:
- Remove entry from .history/.latest.ftd
- Create entry in .history/history.ftd

-- ft.code:
lang: ftd

\-- fpm.history: index.ftd

\--- fpm.status: Deleted
timestamp: v1

-- ft.markdown:

- Remove entry from .fpm/workspace.ftd




-- ft.h1: `file-deleted-after-already-modified`

Before sync:

Delete the file

After sync:
- Return conflict (index.v1.ftd: content and version)
- Create entry in .fpm/workspace.ftd

-- ft.code:
lang: ftd

\-- fpm.workspace: index.ftd
version: v2

-- ft.markdown:

- It won't restore the file in fs





-- ft.h1: `file-deleted-after-already-deleted`


Before sync:

Delete file in file system

After sync:

Nothing

- Remove entry from `.fpm/workspace.ftd`




-- ft.h1: `file-modified`

Before sync:

modify the file

After sync:

- Create new snapshot .history/index.v2.ftd
- Create entry in .latest.ftd
- Create entry in .history/history.ftd



-- ft.h1: `file-modified-after-already-deleted`

Before sync:

modify the file

After sync:

Nothing



-- ft.h1: `file-modified-after-already-modified`

Before sync:

modify the file

After sync:

Nothing



