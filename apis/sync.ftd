-- ft.page: API `/-/sync/`

In sync, It will perform two way merge, Firstly pull content from fpm remote(fpm
is running in remote mode) to fpm local client and if it succeed then it will
merge client's local change to fpm remote.


-- ft.h1: How We Will Implement

-- ft.h2: Version 1

- Client will ask `latest.ftd` from `fpm remote` server
- Then it will compare local content with server's `latest.ftd`
- If `latest.ftd` is diverged then it will ask updated files from `fpm remote`
server

- Server will send updated files to Client
- Client will update local content according to `latest.ftd`. It may be possible
that conflicts occur and client will solve conflicts. If any merged conflicts
occurred `sync` will stop it's process.

- Send updated file to server back. In this case it will use sync API.
- It may be possible till client send back updated content to server, server
content has diverged and conflicts occur again. Then client has to resolve
conflicts and run `fpm sync` again.

-- ft.h2: Version 2

- Client will send it's `latest.ftd` and updated content to server and server
will compare client's `latest.ftd` and server's `latest.ftd` and send back
updated content in response according to server's `latest.ftd`.

- Client will update its local content, If merge conflicts occurred then `sync`
will stop it's process.
- Client will send updated content back to server. In this case it will call
sync API.
- It may be possible till client send back updated content to server, server
content has diverged and conflicts occur again. Then client has to resolve
conflicts and run `sync` again.


-- ft.h1: API POST `/-/sync/`

- Header:
    - cookie: `identity`

- URL:
    - `/-/sync/`

- Request Body

-- ft.code:
lang: json
{
    "package_name": "<Name of the package>",
    "files": [
        {
            "action": "Add/Update",
            "path": "<Absolute file path>",
            "content": "file content"
        },
        {
            "action": "Delete",
            "path": "<Absolute file path>",
        }
    ],
    "latest_ftd": "latest ftd content"
}

-- ft.h1: How Will It Work

Get the document from filesystem with request `path` and latest document version
from `latest.ftd`, compare both versions, request `version` and latest version.

If both the versions are same:

Merge the content of both, save it in database and calculate the new version
version and update it into `latest.ftd`.

If both the versions are not same:

Then it has to perform three way merge, to perform three way merge it needs
three documents to merge together, file `content` in request, content from
filesystem(latest version on the remote) and least common ancestor of both of
these.

In performing three way merge, If there is conflict then return conflicted content
to client with remote latest version, else no conflicts, then save merged content
into filesystem and update latest version in `latest.ftd` and return latest
version of the document.


-- ft.h1: Responses

-- ft.h2: Success Response Without Conflict

-- ftd.code:
lang: json
{
    "success": true,
    "code": "OK",
    "data": {
        "files": [
            {
                "action": "Update",
                "path": "Absolute file path",
                "status": "NoConflict",
                "content": "file content"
            },
            {
                "action": "Add",
                "path": "Absolute file path",
                "status": "NoConflict",
                "content": "file content"
            },
            {
                "action": "Delete",
                "path": "Absolute file path",
            },
            {
                "action": "Update",
                "path": "Absolute file path",
                "status": "Conflict",
                "content": "file content"
            },
        ],
        "dot_history": {
            "files": [
                {
                    "path": "file path",
                    "content": "content of the file"
                }
            ]
        },
        "latest_ftd": "Content of latest ftd file"
    }
}


-- ft.h2: Error Response

-- ftd.code:
lang: json
{
    "success": false,
    "code": "UN_AUTHORIZED", // May be not needed
    "message": "You do not have access to update this document",
}


-- ft.h1: Partial Sync

Sync operation will be performed partially as well, by mean of partial let's say
there are five documents, 2 have no conflicts and 3 have conflicts, so 2 document
will be synced and 3 document will be returned with conflicted content with
server's latest version.


-- ft.h2: Version Data Structure

- path: file absolute path
- hash: SHA256 of the content
- author: Who has done this write
- message: If provided any
- datetime: When this has done
- incremental version number


-- ft.h1: Scenarios

-- ft.h2: Scenario 1: If a file is deleted from remote and updated in local

We will always give priority to update

-- ft.h2: Scenario 2: If a file is updated in remote and deleted in local

We will always give priority to update


-- ft.code: Sync Curl Request
lang: sh

curl --location --request POST 'http://127.0.0.1:8000/-/sync/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "package_name": "arpita",
    "files": [
        {
            "action": "Add",
            "path": "this is file path",
            "content": [61,73, 64, 61, 73, 64, 61, 73, 64, 73]
        }
    ],
    "latest_ftd": "asdasd"
}'


-- ft.h1: How To

- Get all the updated, added and deleted files
- Get Updated Files -> If content differs from latest snapshot
- Get Added Files -> If files does not present in latest snapshot
- Get Deleted Files -> If file present in latest.ftd and not present in directory
