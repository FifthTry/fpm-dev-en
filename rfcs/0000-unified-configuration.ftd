-- import: fastn.com/rfcs/lib
-- import: fastn-community.github.io/bling/note

-- lib.rfc: RFC: Unified Configuration
id: unified-config
status: proposal

TODO: Write a brief summary of the RFC here.


-- lib.motivation:

;; TODO: add links to the following paragraph
Currently, `fastn` supports configuration through environment variables, and in
some way, through the `FASTN.ftd` file. Environment variables are good to
change the behaviour of the cli or to pass secret information but it's not
ideal for defining complex configuration for a framework like `fastn` that
provides various configurable features like processors, oauth authentication
and, apps.

;; TODO: I can do better than this
This RFC proposes a way of dealing with configuration that is centralised and
leveraged the existing ability of the `fastn` cli to read environment
variables.

-- end: lib.motivation


-- lib.detailed-design:

-- ds.h2: `fastn/config` - A virtual module to assist configuration definition.

Add a virtual module (`fastn/config`) similar to existing [assets](TODO: add
link) module.

;; TODO add footer section for explanors like foreign variables and virtual module
- This module contains all special configuration types defined by the fastn
  framework. This module also provides safe access to environment variables
  through foreign variables.

- `FASTN.ftd` file will be central to the whole configuration system. Users can
  modify the behaviour of a dependency by passing variables when they're added.
  Example:

-- ds.code:
lang: ftd

;; FASTN.ftd of test-todos
\-- import: fastn

\-- fastn.package: test-todos

\;; fastn.app works in similar way
\-- fastn.dependency: amitu.com/todos
max-todo-per-page: 30
ignore-value: test \;; amitu.com/todos doesn't have this variable so we ignore this

-- end: ds.code


-- ds.markdown:

The above snippet is configuring `amitu.com/todos` by modifying variables that
are in its `FASTN.ftd` file.

The `FASTN.ftd` of `amitu.com/todos` will look like this:

-- ds.code:
lang: ftd

;; FASTN.ftd of amitu.com/todos
\-- import: fastn

\-- fastn.package: amitu.com/todos

\-- integer max-todo-per-page: 10 \;; becomes 30 when used by test-todos

\-- string sample-title: TODO App \;; this was not modified by test-todos so this stays intact

-- end: ds.code


-- ds.markdown:

- While adding dependency, users can modify any variable defined in the
  `FASTN.ftd` file of the said dependency. Any variable that is not defined
  there is simply ignored

- Variables defined in `FASTN.ftd` are also considered by the framework
  features. Example: Github OAuth feature (this is a processor) can specify
  that it needs `gh-oauth` variable of type `github` defined in user's
  `FASTN.ftd` file for it to work in user's `FASTN.ftd` file for it to work
  (the error handling when `gh-oauth` is not available depends on the
  implementation).

- Variables created using types from `fastn/congi` (as well as primitive types)
  are normal variables that can be defined in any `.ftd` file.

- Only the variables defined in `FASTN.ftd` will be available for access from
  `fastn/config` module. See this example to see how one would use a config
  variable creatd elsewhere ;; TODO: add example

Q. Why do we allow defining config variables outside of `FASTN.ftd`?

<start of answer>

Configurations are meant to modify the behaviour of the framework or an
external fastn package. Even though this change in behaviour or modification in
configuration of a package should happen in `FASTN.ftd` file, we should give
users option to define configuration that are scoped for a single use.

Consider the following example that uses the [pg processor]():

-- ds.code:
lang: ftd

\;; sample.ftd
\-- import: fastn/processors as pr
\-- import: fastn/config

\-- config.db-conn temp:
db_host: <some_ip>
db_user: user
db_password: config.DB_PASSWORD ;; this is an environment variable
db_name: user_db

\-- person list people:
$processor$: pr.pg
use: $temp

SELECT * FROM users;


-- note.note:

If the use of pg processor doesn't specify database connections information
through the `use` header, the implementation of `pg` can choose to look for a
default variable (say `db`) in `FASTN.ftd`. Looking into arbitray `.ftd` file
is not supported. Any rust implementation will only be able to access variables
defined in `FASTN.ftd` for configuration stuff.


-- ds.markdown:

In summary, a processor like `pg` would say: "Pass connection information
through the `use` header or it'll pick `db` variable of type `config.db-conn`
from your `FASTN.ftd` file.

<end of answer>


-- ds.h2: TODO

- Write implementation details.


-- end: lib.detailed-design


-- lib.alternatives:

Did you consider any alternatives to what you propose in detailed-design, if so
mention them here, along with discussion on why you consider the proposal better.

-- end: lib.alternatives




-- lib.teaching-notes:

How hard would it be to teach this feature?

-- end: lib.teaching-notes



-- lib.unresolved-questions:

List unresolved questions here.

-- end: lib.unresolved-questions



-- end: lib.rfc


