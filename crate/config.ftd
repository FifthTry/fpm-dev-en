-- ft.page: `fpm::Config`

`fpm::Config` struct keeps track of configuration for a FPM package. In order
to perform any operation on a package, this struct should be first created.

`fpm::Config::read()` can be used to construct `fpm::Config` struct.


-- ft.code:
lang: rs


#[derive(Debug, Clone)]
pub struct Config {
    pub package: fpm::Package,
    /// `root` is the package root folder, this is the folder where `FPM.ftd` file is stored.
    ///
    /// Technically the rest of the program can simply call `std::env::current_dir()` and that
    /// is guaranteed to be same as `Config.root`, but `Config.root` is camino path, instead of
    /// std::path::Path, so we can treat `root` as a handy helper.
    ///
    /// A utility that returns camino version of `current_dir()` may be used in future.
    pub root: camino::Utf8PathBuf,
    /// Keeps a track of the package root for a particular config. For a dep2 of a dep1,
    /// this could point to the <original_root>/.packages/
    /// whereas the project root could be at <original_root>/.packages/<dep1_root>
    pub packages_root: camino::Utf8PathBuf,
    /// `original_directory` is the directory from which the `fpm` command was invoked
    ///
    /// During the execution of `fpm`, we change the directory to the package root so the program
    /// can be written with the assumption that they are running from package `root`.
    ///
    /// When printing filenames for users consumption we want to print the paths relative to the
    /// `original_directory`, so we keep track of the original directory.
    pub original_directory: camino::Utf8PathBuf,
    /// The extra_data stores the data passed for variables in ftd files as context.
    ///
    /// This data is processed by `get-data` processor.
    pub extra_data: serde_json::Map<String, serde_json::Value>,
    /// `current_document` stores the document id (Eg: `foo.ftd` or `bar/foo.ftd`) which is
    /// currently in building process.
    /// It's value is injected by `fpm::build()` function according to the currently processing
    /// document.
    /// It is consumed by the `sitemap` processor.
    pub current_document: Option<String>,
    /// `all_packages` stores the package data for all the packages that are dependencies
    /// of current package directly or indirectly. It also includes current package,
    /// translation packages, original package (of which the current package is translation)
    /// The key store the name of the package and value stores corresponding package data
    pub all_packages: std::collections::BTreeMap<String, fpm::Package>,
    pub downloaded_assets: std::collections::BTreeMap<String, String>,
}


-- ft.h1: `fpm::Config::read()`

`fpm::Config::read()` finds the `FPM.ftd` and creates `fpm::Config` struct.

-- ft.code:
lang: rs

impl fpm::Config {
    pub async fn read(root: Option<String>) -> fpm::Result<fpm::Config>
}

-- ft.markdown:

`fpm::Config::read()` returns a [`fpm::Result`](crate/result/) of `fpm::Config`.


-- ft.h2: `root`

If `root` is passed as `None`, `fpm::Config::read()` looks for `FPM.ftd` file
in the current directory, and if not found keeps searching for it in it's
ancestors till it finds it.

If `root` is passed, it is assumed to be the root of the fpm package, and
`FPM.ftd` file must be present in this folder.


-- ft.h1: `fpm::Config.attach_data_string()`

This function can be used to attach json data to Config. This JSON data is
available to every ftd file that uses [`get-data`
processor](processors/get-data/).

-- ft.code:
lang: rs

impl fpm::Config {
    pub fn attach_data_string(&mut self, json: &str) -> fpm::Result<()>
}

-- ft.markdown:

This should be called before [`fpm::render()`](crate/render/).

Implementaiton note: This function internally calls `fpm::Config::attach_data()`.


-- ft.h1: `fpm::Config.attach_data()`

This function can be used to attach json data to Config. This JSON data is
available to every ftd file that uses [`get-data`
processor](processors/get-data/).

-- ft.code:
lang: rs

impl fpm::Config {
    pub fn attach_data(&mut self, data: &serde_json::Value) -> fpm::Result<()>
}

-- ft.markdown:

This should be called before [`fpm::render()`](crate/render/).


-- ft.h1: `fpm::Config.get_file_by_id(&fpm::Package)`

Given the `id` of a document, this function returns the FTD source of the
document.


-- ft.code:
lang: rs

impl fpm::Config {
    pub fn get_file_by_id(&self, id: &str) -> fpm::Result<fpm::File>
}


-- ft.markdown:

Note this implements fallback feature in case this is a translated package.



-- ft.h1: `fpm::Config.get_files()`

`fpm::Config.get_files()` returns all the ["files"](crate/file/) in a package.

-- ft.code:
lang: rs

pub(crate) async fn get_files(&self, package: &fpm::Package)
    -> fpm::Result<Vec<fpm::File>>



-- ft.h1: `fpm::Config.get_assets()`

`fpm::Config.get_assets()` returns the "assets" automagic module for each
package.

-- ft.code:
lang: rs

pub(crate) async fn get_assets(
    &self,
    base_url: &str,
) -> fpm::Result<std::collections::HashMap<String, String>>

-- ft.markdown:

Key is the package name, and value is FTD source of generated assets module.


