


-- ft.page:


-- ft.h0: FPM Journal


-- ft.h1: 100th Commit! We now honour `.gitignore` etc

8th Dec 2021

Shobhit just [implemented support ignoring files that `git` 
ignores](https://github.com/FifthTry/fpm/commit/c9aded47ef26785a6d49949ddf8b71a09921b5dd). 
You can also ignore more files by populating `fpm.ignore: string list` with 
patterns that are compatible with `.gitignore` file patterns.


-- ft.h1: Some thoughts on Versioning

FPM is for storing documentation and not software. Git is for storing software and
people also use it for storing documentation.


-- ft.h2: Problem With The Way Git / SVN etc Do Versioning

There is a problem with the way Git etc manages versioning that it is not a good 
solution for storing documentation, in my opinion. Traditional "source code 
managers" create a new folder or a branch for managing versioning.

Say you are working on django 1.0 and its time to create django 2.0, you create a
new branch for version 2.0 and start working on it.

At this point the two branches have diverged. All new change now go to 2.0 branch.
You may even make main or master follow the 2.0 branch. For all practical reasons
1.0 has stopped. You will want to be good citizens and support 1.0, back port some
of the bug fixes, especially security fixes. In projects like Linux people even 
backport whole features to older versions.

But back porting is kind of extra work. Most people recommend and send a pull 
request against the latest main/master, and the changes get included in the next
release that is cut from main/master.


-- ft.h2: Documentation and Software Are Different

Back-porting bug fixes and features is kind of hard. You have to verify software
indeed works correctly. You have to write unit tests and verify there are no 
regressions. Software releases and continuous maintenance is work. Its kind of 
usually best to focus efforts on latest version and update as soon as one can.

Documentation on that other hand is lot easier. There is no risk of documentation
breaking anything. Wrong documentation can still have consequences, no doubt about
it, but they are rather rare, compared to software issues. Software is lot more
fragile compared to documentation.

By managing documentation like software we are doing a dis-service. Its the wrong
tool for the job.

One difference in documentation compared to software is that a lot of changes in
documentation are not logical. Eg if the original documentation said this function
takes three arguments and new one says it takes four, this is a logical difference.
But if the original documentation was too terse, and new documentation gives more
examples and explanations and how-tos, the documentation hasn't really changed in
a logical sense.

Its like refactor in software. We know refactor, should not cause any change in
behaviour of software. But in software its really hard to arrive at this 
conclusion, if someone sends a software refactor PR, its really hard to say that 
will really have no effect, that its safe to merge. 

But for documentation its almost trivial to see a PR and conclude that there is
no real "logical" change, that it is just a better written tutorial and has not
changed anything fundamental.


-- ft.h2: Updating Documentation For A Published Version Of Software Must Be Possible

Currently its almost not possible to update django 1.0 documentation without also
creating a new release of django 1.0. And in that case it no longer is updating the
documentation of django 1.0, its updating documentation of django 1.0.1 or 
whatever.


-- ft.h2: Open Source Maintainers Are Busy Enough

Software is a lot of work. Core maintainers have to review every line like a hawk.
To ensure nothing is broken. That there are no edge case. No violation of any 
contract etc.

So sending documentation only PR to review to them, especially to older versions
of the software, its almost going a bit too far, demanding too much from them.


-- ft.h2: The Root Problem In Current Documentation Workflow

If we create a new branch for every new version of software and keep the 
documentation along with software in that branch, we are basically creating a copy
of every file for every version.

Say you have a file `tutorial.txt`, there is one copy of this file in *every* 
version branch. This is the root problem. Even if there is no change in 
`tutorial.txt`, we still copy it over.

We do, what can be called, copy-on-branch, instead of what should be: 
copy-on-incompatible-change.

Lets analyse django:


-- ft.code:
lang: sh

git clone git@github.com:django/django.git
cd django
python t.py
4.0rc1 37 72 27
wc -l tags                                
     312 tags


-- boolean $show-t-py: false


-- ftd.text: Hide `t.py`
if: $show-t-py
$event-click$: toggle $show-t-py


-- ftd.text: Show `t.py`
if: not $show-t-py
$event-click$: toggle $show-t-py


-- ft.code:
if: $show-t-py
lang: py

import sys
import hashlib
import subprocess

def main():
    overview = set()
    tutorial = set()
    install = set()
    for tag in get_tags():
        checkout(tag)
        overview.add(sha256sum("docs/intro/overview.txt")) 
        tutorial.add(sha256sum("docs/intro/tutorial01.txt")) 
        install.add(sha256sum("docs/intro/install.txt")) 
        print(tag, len(overview), len(tutorial), len(install))


def checkout(tag):
    subprocess.run(["git", "checkout", tag]) 

def get_tags():
    return [t.strip() for t in open("tags").readlines()]

def sha256sum(filename):
    h  = hashlib.sha256()
    b  = bytearray(128*1024)
    mv = memoryview(b)
    with open(filename, 'rb', buffering=0) as f:
        for n in iter(lambda : f.readinto(mv), 0):
            h.update(mv[:n])
    return h.hexdigest()

main()


-- ft.markdown:

As you can see, we have 312 tags, and therefore 312 copies of `overview.txt`, 
`tutorial01.txt` and `install.txt` but only 37, 72, and 27 unique content.


-- ft.h1: Copy On Incompatible Change


-- ft.h1: SQLite Support!

7th Dec 2021

Yesterday I [started implementing SQLite 
support](https://github.com/FifthTry/fpm/commit/3c2662a6797495c7ead4b7b3bb9c431616b1bf00) 
for FTD documents via `$processor$` mechanism of `ftd`. It was stuck on some 
missing helper utilities in FTD, you can see the two functions in the end with 
`todo!()` as their body. 

Today Arpita was feeling a bit better from cold, and [PR implementing those 
functions in ftd](https://github.com/FifthTry/ftd/pull/24). She can't not work
even when down it seems!

On that change landed I got the [`$processor$: package-query` 
working](https://github.com/FifthTry/fpm/commit/89d8ba1d1d5f93b5f8b58e306dd8b6b8965f1fb5).
Update the [documentation](/fpm/package-query/) as well.

During implementation I found out that [`serde-json` support for 
rusqlite](https://docs.rs/rusqlite/0.26.1/rusqlite/types/trait.FromSql.html#impl-FromSql-for-Value) is 
actually, umm, not sure what word to use, not buggy per se, but kind of not as 
useful as I first thought it would be. It converts only text field to 
`serde_json::Value`, when other fields like integer, float etc can also be easily
converted to `serde_json::Value`. I implemented a [simple converter for other 
sqlite data types as well](https://github.com/FifthTry/fpm/blob/53492bb14f16983569184f0acfd9c1f45ddf1c32/src/library/sqlite.rs#L102-L108).

We are not done yet. We need an ability to pass parameters to queries. Also those
parameters should be able to refer to other ftd variables. And finally we should be
able to read into more types, currently we only read into records and list of 
records.


-- ft.h1: Some thoughts on Translation Support

So we have reasonable `sync`/`status`/`diff` working now. We are going to soon 
implement "ad hoc tracking", basically a `.track` folder which contains `foo.track`
like file for each `foo.ftd` file. `status`/`diff` will look into the `.track` file
for any file and see if they are up to date with respect to the files being 
tracked.

Once we have ad-hoc tracking, we are going to work on translation tracking, where
a package would be able to designate itself to be a translation of another package
using `translation-of` key in `FPM.ftd`. When a package tracks another package like
this it means two things.


-- ft.h2: Every File Tracks Corresponding File

All files of the translation package is assumed to be tracking corresponding file
for the original package being translated.

In ad-hoc tracking you have to explicitly add tracking information using planned
`fpm a tracks b` command. But with translation, tracking relationships are 
implicitly assumed.


-- ft.h2: Missing Files and Fallback

It also means that if a file is absent in translation package, the corresponding
file from the original package is built. 

So to create a translation of another package, you can create an empty package, and
all files of original would be the content of the translation package. And then
you can start translating one file at a time by copying over just that file, so you
do not have to litter your package with files that are just plain copies.


-- ft.h2: Out Of Date File's HTML

So we have translation tracking, which means we know if a file is upto date with
the corresponding file in original package, translation is complete for that file,
but what if its not up to date? Or even it was never finished? What you just 
created the translation file, have only translated the heading, what should we show
in those cases?

So far, given a file `a.ftd`, we convert it to `a.html` and that's it. But now for
a file `translated:a.ftd` we have `original:a.ftd`. So we have to consider two 
files when generating `a.html`. In simple case, where `translated:a.ftd` is "up to 
date", we render `translated:a.ftd` and that is that. But if `translated:a.ftd` is
missing or not up to date, we have to include content of both (and two potential
diffs, diff of `original:a.ftd` from the date `translated:a.ftd` was last marked
up to date by a human being, to the latest `original:a.ftd`, and diff of 
`translated:a.ftd` when and if it was marked updated date last to latest).

So we have two ftd files and two diffs, and possibly some meta data to include in
the generated `a.html`. We also need some JS to let people switch between 
potentially out of date or incomplete translation and original version. And we
need an area to show some out of date warning, and some UI to show / hide the two
diffs.


-- ft.h2: User's Area vs Special Area?

Now that we have more than the content of a `ftd` file to render in any generated
`.html` file, we have to ask ourselves if we should split our UI in two logical 
area, an area completely controlled by end user using ftd, and another for the 
special stuff, like translation out of date messaging?

Tomorrow we will have more stuff, like when we add versioning support, we would
want to show "you are looking at old version, jump to latest version" eg docs.rs 
etc, but then if you are seeing a specific version, you want to see two diffs as
well: diff of what changed in this precise release, so diff from last version to
this version, and diff of this version with the latest version. It would be good
if these two bits of info were available at a finger tip without doing complex git
diff incantations. 

For both versioning and translation we need to show some sort of "switcher", go to
another language or version of this document.

We can do these by special variables. We can expect each "theme" to know about 
these special variable, and the theme author can include the UI in most logical 
place. 

We can also create dedicated "document info" area, say a banner at the top, and 
then theme does not need to bother with all that.

We can even let people customise say `FPM/document-info.ftd` file whose content 
would included in the special area.

And finally we can let these writers specify that they have indeed included the
document info in the theme itself and `fpm` should not show 
`FPM/document-info.ftd`, maybe we inherit `FPM/document-info` from the theme and
let the theme set it to empty file?

There is a little complexity when a FTD document basically says unload me and load
some other document. We do not have a FTD way to do this yet. Not sure if its a
good idea.

The thing is this is a lot of complexity and a lot of potential changes, at least 
in the early days, leaving it for each theme to individually manage would be a bad
idea as then the confidence with which you can switch theme will go down as you 
will have to verify more things, and not just the look and feel of a theme.


-- ft.h1: Started Design

6th Dec 2021

Jay has created a logo that we kind of like, and some initial design for our 
homepage:


-- ft.image:
src: https://i.imgur.com/axb1vKD.png

This is still under works.


-- ft.h1: Sqlite Support

Since we are anyways going to implement some sqlite support for [package 
database](/fpm/~/16/), we may as well let people include arbitrary sqlite files in 
the package, and let people do arbitrary SQL queries on top of any of the sqlite 
databases in the package or any package that is a dependency of this package.

[Change Request](/fpm/~/26/).

[Partially implemented `$processor$: 
package-query`](https://github.com/FifthTry/fpm/commit/3c2662a6797495c7ead4b7b3bb9c431616b1bf00).
Need two methods in `ftd` crate, waiting for Arpita to get better and implement
them.


-- ft.h1: Dynamic Documents and FPM Action

Recently I implemented `$processor$: http`, which paves the way for almost fully
fledged ["dynamic"/data drive documents](///www.fifthtry.com/fpm/~/20/). To really
expose this feature, we can implement arbitrary URL handing, currently only the 
URLs corresponding to actual FTD files is available, this is too limiting as we can
not have author page for example, where we need a URL for each author, and author 
list maybe in a table, or spread all over ftd documents. 

With a `FPM/URLs.ftd`, we can define URL patterns that can contain dynamic data, eg
`/<username>/` etc. We can map each URL pattern to a FTD file, and the file can 
extract the data by defining a schema (eg a record), where the fields of record 
would be populated by URL query parameters, URL fragments (eg `username`) here, or
even request body if its available.

We will sometime need redirect etc, eg if you need login to access something, or
if the page has moved etc. So we need a mechanism to early return, currently its
not possible in a FTD document to let a document say we are done processing the
page. At least we can have some standard variable, eg `fpm.redirect-url`, which 
when set, FPM will ignore the document and return the content of `fpm.redirect-url`
instead, along with some instruction to `fpm.js` to update the URL displayed in
browser.

This is almost the design of [`realm`](///www.amitu.com/realm/). Once I wrote that
I realised we also need an equivalent of "realm actions", and turned out the design
is really easy. Wrote about it in another CR: [fpm 
actions](///www.fifthtry.com/fpm/~/24/). 

The key element of actions is now we need a `fpm.js`, which will have some 
behaviour, and this paves the way for [fpm client 
variables](///www.fifthtry.com/fpm/~/25/).


-- ft.h1: Client Variables

Some variables can only be computed by client. So we need to ship a `fpm.js`, which
will compute them, and pass them to FTD. Some of these variables would also change
during the lifetime of the page.

`fpm.js` will also do some browser history control, for managing server side 
"internal redirect", and `fpm actions`.


-- ft.h1: `fpm sync`, `fpm status` and `fpm diff`

5th Dec 2021

Arpita has been on fire, implemented these three commands. This makes `fpm` puts
some "version control" features in `fpm`. Our goal is not become simplified git,
we definitely take a lot of inspiration from them, but more like advance 
Dropbox/iCloud.

`fpm repo` is needed before we can really call ourselves version control or compare
ourselves with Dropbox/iCloud etc. But if you are using Dropbox/iCloud, you can
already benefit from these commands.

Our goal now is to implement [`adhoc tracking`](/fpm/~/12/), and get to 
[`translation tracking`](/fpm/~/3/).


-- ft.h1: `$processor$: toc` and `$processor$: http`

5th Dec 2021

We implemented [these two processors](/fpm/processors/). TOC processor helps you 
when you are trying to create navigation bars, or table of content of your FPM 
site (this is not the intra page TOC, which we still do not know how to implement).

`$processor$: http` lets you fetch data from any HTTP endpoint that returns JSON 
when rendering a FTD document. It opens up massive opportunities, you can fetch 
data from all sorts of places, data driven graphs and tables etc can be created.


-- ft.h1: Font Support

4th Dec 2021

We just added font support. This allows people to use custom fonts with FTD/FPM.

You can specify the fonts you want loaded in [`FPM.ftd`](/fpm/FPM/) file.


-- ft.h1: Package Dependency Fetching

3rd Dec 2021

Shobhit added support for adding package dependency, and fetching dependencies from
Github or any tar file. We store the dependencies in `.packages`.

Lots still pending, recursive package dependency, or any way to update a package,
looking for packages in FPM_HOME, but its exciting to have this feature land so
soon.


-- ft.h1: Package Database

1st Dec 2021

Wrote about the design of [package database](/fpm/~/16/), basically a sqlite 
database that we will maintain in the initial phase of `fpm build`, and a way to
query that database to get data stored in different ftd documents that are part
of the FPM package.

This can make fpm packages the ideal data sharing format. You can have data 
authored in FTD, and packaged as FPM package, along with some UI code, and publish
them to `fpm repo`. And then other packages can have a dependency on the original 
data package, fpm will download the data, and they can do something more with it, 
create more visualisations, augment data even more using `$processors$` etc, and
maybe publish that package again for other to consume.


-- ft.h1: Update for 30th Nov 2021

Shobhit is working full time on FPM now. We managed to nail down quite a bit of 
our design now.


-- ft.h2: `fpm build` working

Finally we can start using `fpm`. We have created a template repo: 
[FifthTry/fpm-blog](https://github.com/FifthTry/fpm-blog), [rendered 
version](https://fifthtry.github.io/fpm-blog/), which shows how to create a blog 
using FTD and FPM.


-- ft.h2: Design Review With Arpita

Me and Arpita recorded a detailed design review of FPM.


-- ft.youtube:
id: rny1EGkqw_M


-- ft.h1: Kickoff

25th Nov 2021

We have started working on this project now. We have written design docs for quite
a few elements:

- `fpm build`: [file system organization](/fpm/~/1/)
- [logical linking](/fpm/~/2/)
- [translation tracking](/fpm/~/3/)
- [version tracking](/fpm/~/5/)
- [history tracking](/fpm/~/4/)
- [cr tracking](/fpm/~/6/)
- [upstream tracking: two way sync](/fpm/~/7/)
- [`fpm-repo` authentication](/fpm/~/8/)
- [package dependencies](/fpm/~/9/)
- [access control](/fpm/~/10/)

[Shobhit](https://github.com/sharmashobit) is taking the lead of implementing this.
We are hoping to create a minimal version that can convert ftd files to HTML so
`fpm` can be considered an alternative to static site generators.
